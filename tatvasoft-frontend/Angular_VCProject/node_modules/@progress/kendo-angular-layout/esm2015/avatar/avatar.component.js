/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, HostBinding, Input, isDevMode } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { getStylingClasses, mapShapeToRounded } from '../common/util';
import { packageMetadata } from '../package-metadata';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
const DEFAULT_ROUNDED = 'full';
const DEFAULT_SIZE = 'medium';
const DEFAULT_THEME_COLOR = 'primary';
const DEFAULT_FILL_MODE = 'solid';
/**
 * Displays images, icons or initials representing people or other entities.
 */
export class AvatarComponent {
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
        /**
         * Sets a border to the avatar.
         */
        this.border = false;
        this._themeColor = DEFAULT_THEME_COLOR;
        this._size = DEFAULT_SIZE;
        this._fillMode = DEFAULT_FILL_MODE;
        this._rounded = DEFAULT_ROUNDED;
        validatePackage(packageMetadata);
    }
    /**
     * @hidden
     */
    get borderClass() {
        return this.border;
    }
    /**
     * @hidden
     */
    get flexBasis() {
        return this.width;
    }
    /**
     * Sets the shape for the avatar.
     * @hidden
     */
    set shape(shape) {
        this.rounded = mapShapeToRounded(shape);
    }
    /**
     * Specifies the size of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-size)).
     *
     * The possible values are:
     * * `small`
     * * `medium` (Default)
     * * `large`
     * * `none`
     */
    set size(size) {
        if (size !== this._size) {
            const newSize = size ? size : DEFAULT_SIZE;
            this.handleClasses('size', newSize);
            this._size = newSize;
        }
    }
    get size() {
        return this._size;
    }
    /**
     * Specifies the rounded styling of the avatar
     * ([see example]({% slug appearance_avatar %}#toc-rounded-corners)).
     *
     * The possible values are:
     * * `small`
     * * `medium`
     * * `large`
     * * `full` (Default)
     * * `none`
     */
    set rounded(rounded) {
        if (rounded !== this._rounded) {
            const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
            this.handleClasses('rounded', newRounded);
            this._rounded = newRounded;
        }
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Specifies the theme color of the avatar.
     * The theme color will be applied as background and border color, while also amending the text color accordingly.
     *
     * The possible values are:
     * * `base`&mdash; Applies the base coloring value.
     * * `primary` (Default)&mdash;Applies coloring based on primary theme color.
     * * `secondary`&mdash;Applies coloring based on secondary theme color.
     * * `tertiary`&mdash; Applies coloring based on tertiary theme color.
     * * `info`&mdash;Applies coloring based on info theme color.
     * * `success`&mdash; Applies coloring based on success theme color.
     * * `warning`&mdash; Applies coloring based on warning theme color.
     * * `error`&mdash; Applies coloring based on error theme color.
     * * `dark`&mdash; Applies coloring based on dark theme color.
     * * `light`&mdash; Applies coloring based on light theme color.
     * * `inverse`&mdash; Applies coloring based on inverted theme color.
     * * `none`&mdash; Removes the styling associated with the theme color.
     */
    set themeColor(themeColor) {
        if (themeColor !== this._themeColor) {
            const newThemeColor = themeColor ? themeColor : DEFAULT_THEME_COLOR;
            this._themeColor = newThemeColor;
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get themeColor() {
        return this._themeColor;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     *
     * The possible values are:
     * * `solid` (Default)
     * * `outline`
     * * `none`
     */
    set fillMode(fillMode) {
        if (fillMode !== this.fillMode) {
            const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
            this._fillMode = newFillMode;
            this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
        }
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Specifies the appearance fill style of the avatar.
     * Deprecated, left for backward compatibility.
     *
     * @hidden
     */
    set fill(fillMode) {
        this.fillMode = fillMode;
    }
    /**
     * @hidden
     */
    get avatarWidth() {
        return this.width;
    }
    /**
     * @hidden
     */
    get avatarHeight() {
        return this.height;
    }
    ngOnInit() {
        this.verifyProperties();
    }
    ngAfterViewInit() {
        const stylingInputs = ['size', 'rounded'];
        stylingInputs.forEach(input => {
            this.handleClasses(input, this[input]);
        });
        this.handleFillModeAndThemeColorClasses(this.fillMode, this.themeColor);
    }
    /**
     * @hidden
     */
    iconClasses() {
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
        if (this.iconClass) {
            return `${this.iconClass}`;
        }
    }
    /**
     * @hidden
     */
    get customAvatar() {
        return !(this.imageSrc || this.initials || this.icon || this.iconClass);
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        const inputs = [this.icon || this.iconClass, this.imageSrc, this.initials];
        const inputsLength = inputs.filter((value) => value).length;
        if (inputsLength > 1) {
            throw new Error(`
                Invalid property configuration given.
                The kendo-avatar component can accept only one of:
                icon, imageSrc or initials properties.
            `);
        }
    }
    handleClasses(styleType, value) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('avatar', styleType, this[styleType], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    handleFillModeAndThemeColorClasses(fill, themeColor) {
        const wrapperElement = this.element.nativeElement;
        // remove existing fill and theme color classes
        const currentClasses = Array.from(wrapperElement.classList);
        const classesToRemove = currentClasses.filter(cl => {
            return cl.startsWith('k-avatar-solid') || cl.startsWith('k-avatar-outline');
        });
        classesToRemove.forEach((cl => this.renderer.removeClass(wrapperElement, cl)));
        // add fill if needed
        if (fill !== 'none') {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}`);
        }
        // add theme color class if fill and theme color
        if (fill !== 'none' && themeColor !== 'none') {
            this.renderer.addClass(wrapperElement, `k-avatar-${fill}-${themeColor}`);
        }
    }
}
AvatarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AvatarComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
AvatarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: AvatarComponent, selector: "kendo-avatar", inputs: { shape: "shape", size: "size", rounded: "rounded", themeColor: "themeColor", fillMode: "fillMode", fill: "fill", border: "border", iconClass: "iconClass", width: "width", height: "height", cssStyle: "cssStyle", initials: "initials", icon: "icon", imageSrc: "imageSrc" }, host: { properties: { "class.k-avatar": "this.hostClass", "class.k-avatar-bordered": "this.borderClass", "style.flexBasis": "this.flexBasis", "style.width": "this.avatarWidth", "style.height": "this.avatarHeight" } }, ngImport: i0, template: `
        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <span class="k-avatar-image">
                <img src="{{imageSrc}}" [ngStyle]="cssStyle" />
            </span>
        </ng-container>

        <ng-container *ngIf="initials">
            <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass">
            <span class="k-avatar-icon">
                <span [ngStyle]="cssStyle" [ngClass]="iconClasses()"></span>
            </span>
        </ng-container>
    `, isInline: true, directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-avatar',
                    template: `
        <ng-content *ngIf="customAvatar"></ng-content>

        <ng-container *ngIf="imageSrc">
            <span class="k-avatar-image">
                <img src="{{imageSrc}}" [ngStyle]="cssStyle" />
            </span>
        </ng-container>

        <ng-container *ngIf="initials">
            <span class="k-avatar-text" [ngStyle]="cssStyle">{{ initials.substring(0, 2) }}</span>
        </ng-container>

        <ng-container *ngIf="icon || iconClass">
            <span class="k-avatar-icon">
                <span [ngStyle]="cssStyle" [ngClass]="iconClasses()"></span>
            </span>
        </ng-container>
    `
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-avatar']
            }], borderClass: [{
                type: HostBinding,
                args: ['class.k-avatar-bordered']
            }], flexBasis: [{
                type: HostBinding,
                args: ['style.flexBasis']
            }], shape: [{
                type: Input
            }], size: [{
                type: Input
            }], rounded: [{
                type: Input
            }], themeColor: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], fill: [{
                type: Input
            }], border: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], width: [{
                type: Input
            }], avatarWidth: [{
                type: HostBinding,
                args: ['style.width']
            }], height: [{
                type: Input
            }], avatarHeight: [{
                type: HostBinding,
                args: ['style.height']
            }], cssStyle: [{
                type: Input
            }], initials: [{
                type: Input
            }], icon: [{
                type: Input
            }], imageSrc: [{
                type: Input
            }] } });
