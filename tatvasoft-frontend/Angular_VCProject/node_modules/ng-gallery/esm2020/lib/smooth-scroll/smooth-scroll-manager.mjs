import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
// @dynamic
export class SmoothScrollManager {
    constructor(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...customDefaultOptions,
        };
    }
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance?.now?.bind(this._w.performance) || Date.now;
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => subscriber.next(context));
        });
    }
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        const destroyed = this._initSmoothScroll(el);
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(resolve => {
            // Scroll each step recursively
            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();
        });
    }
    /**
     * Dismiss an ongoing scroll
     * @param el
     */
    dismissOngoingScroll(el) {
        this._onGoingScrolls.get(el)?.next();
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            const el = this._getElement(scrollable);
            const isRtl = getComputedStyle(el).direction === 'rtl';
            const rtlScrollAxisType = getRtlScrollAxisType();
            const options = {
                ...this._defaultOptions,
                ...customOptions,
                ...{
                    // Rewrite start & end offsets as right or left offsets.
                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
                }
            };
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this._getElement(scrollable);
        const targetEl = this._getElement(target, scrollableEl);
        const options = {
            ...customOptions,
            ...{
                left: targetEl.offsetLeft + (customOptions.left || 0),
                top: targetEl.offsetTop + (customOptions.top || 0)
            }
        };
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    }
}
SmoothScrollManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.3", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
SmoothScrollManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.3", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.3", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SMOOTH_SCROLL_OPTIONS]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ2FsbGVyeS9zcmMvbGliL3Ntb290aC1zY3JvbGwvc21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBYyxNQUFNLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEYsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsb0JBQW9CLEVBQXFCLE1BQU0sdUJBQXVCLENBQUM7QUFFaEYsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDN0UsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RSxPQUFPLFlBQVksTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxFQUNMLHFCQUFxQixFQUt0QixNQUFNLHVCQUF1QixDQUFDOztBQUUvQixXQUFXO0FBSVgsTUFBTSxPQUFPLG1CQUFtQjtJQXNCOUIsWUFBc0MsU0FBbUIsRUFDaEIsU0FBaUIsRUFDSCxvQkFBMkM7UUFGNUQsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUNoQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBbEIxRCxvR0FBb0c7UUFDcEcsbUdBQW1HO1FBQ25HLG9HQUFvRztRQUNwRyxxREFBcUQ7UUFDN0Msb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBOEIsQ0FBQztRQWdCOUQsSUFBSSxDQUFDLGVBQWUsR0FBRztZQUNyQixRQUFRLEVBQUUs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LFlBQVksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3hELE1BQU0sT0FBTyxHQUEwQjtZQUNyQyxHQUFHLGFBQWE7WUFDaEIsR0FBRztnQkFDRCxJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO2dCQUNyRCxHQUFHLEVBQUUsUUFBUSxDQUFDLFNBQVMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO2FBQ25EO1NBQ0YsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzdFLENBQUM7O2dIQWhPVSxtQkFBbUIsa0JBc0JWLFFBQVEsYUFDUixXQUFXLGFBQ0MscUJBQXFCO29IQXhCMUMsbUJBQW1CLGNBRmxCLE1BQU07MkZBRVAsbUJBQW1CO2tCQUgvQixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7MEJBdUJjLE1BQU07MkJBQUMsUUFBUTs7MEJBQ2YsTUFBTTsyQkFBQyxXQUFXOzswQkFDbEIsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBjb2VyY2VFbGVtZW50IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHsgZ2V0UnRsU2Nyb2xsQXhpc1R5cGUsIFJ0bFNjcm9sbEF4aXNUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcclxuaW1wb3J0IHsgX0JvdHRvbSwgX0xlZnQsIF9SaWdodCwgX1RvcCwgX1dpdGhvdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBtZXJnZSwgb2YsIE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmliZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZXhwYW5kLCBmaW5hbGl6ZSwgdGFrZSwgdGFrZVVudGlsLCB0YWtlV2hpbGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCBCZXppZXJFYXNpbmcgZnJvbSAnYmV6aWVyLWVhc2luZyc7XHJcbmltcG9ydCB7XHJcbiAgU01PT1RIX1NDUk9MTF9PUFRJT05TLFxyXG4gIFNtb290aFNjcm9sbEVsZW1lbnQsXHJcbiAgU21vb3RoU2Nyb2xsU3RlcCxcclxuICBTbW9vdGhTY3JvbGxUb0VsZW1lbnRPcHRpb25zLFxyXG4gIFNtb290aFNjcm9sbFRvT3B0aW9uc1xyXG59IGZyb20gJy4vc21vb3RoLXNjcm9sbC5tb2RlbCc7XHJcblxyXG4vLyBAZHluYW1pY1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTbW9vdGhTY3JvbGxNYW5hZ2VyIHtcclxuXHJcbiAgLy8gRGVmYXVsdCBvcHRpb25zXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfZGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucztcclxuXHJcbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG9uZ29pbmcgU21vb3RoU2Nyb2xsIGZ1bmN0aW9ucywgc28gdGhleSBjYW4gYmUgaGFuZGxlZCBpbiBjYXNlIG9mIGR1cGxpY2F0aW9uLlxyXG4gIC8vIEVhY2ggc2Nyb2xsZWQgZWxlbWVudCBnZXRzIGEgZGVzdHJveWVyIHN0cmVhbSB3aGljaCBnZXRzIGRlbGV0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gIC8vIFB1cnBvc2U6IElmIHVzZXIgY2FsbGVkIGEgc2Nyb2xsIGZ1bmN0aW9uIGFnYWluIG9uIHRoZSBzYW1lIGVsZW1lbnQgYmVmb3JlIHRoZSBzY3JvbGxzIGNvbXBsZXRlcyxcclxuICAvLyBpdCBjYW5jZWxzIHRoZSBvbmdvaW5nIHNjcm9sbCBhbmQgc3RhcnRzIGEgbmV3IG9uZVxyXG4gIHByaXZhdGUgX29uR29pbmdTY3JvbGxzID0gbmV3IE1hcDxIVE1MRWxlbWVudCwgU3ViamVjdDx2b2lkPj4oKTtcclxuXHJcbiAgcHJpdmF0ZSBnZXQgX3coKTogV2luZG93IHtcclxuICAgIHJldHVybiB0aGlzLl9kb2N1bWVudC5kZWZhdWx0VmlldztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWluZyBtZXRob2RcclxuICAgKi9cclxuICBwcml2YXRlIGdldCBfbm93KCk6ICgpID0+IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fdy5wZXJmb3JtYW5jZT8ubm93Py5iaW5kKHRoaXMuX3cucGVyZm9ybWFuY2UpIHx8IERhdGUubm93O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IERvY3VtZW50LFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtOiBvYmplY3QsXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChTTU9PVEhfU0NST0xMX09QVElPTlMpIGN1c3RvbURlZmF1bHRPcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpIHtcclxuICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICBkdXJhdGlvbjogNDY4LFxyXG4gICAgICBlYXNpbmc6IHtcclxuICAgICAgICB4MTogMC40MixcclxuICAgICAgICB5MTogMCxcclxuICAgICAgICB4MjogMC41OCxcclxuICAgICAgICB5MjogMVxyXG4gICAgICB9LFxyXG4gICAgICAuLi5jdXN0b21EZWZhdWx0T3B0aW9ucyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50LCB4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgZWwuc2Nyb2xsTGVmdCA9IHg7XHJcbiAgICBlbC5zY3JvbGxUb3AgPSB5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBhIGdpdmVuIHBhcmFtZXRlciBvZiB0eXBlIEhUTUxFbGVtZW50LCBFbGVtZW50UmVmIG9yIHNlbGVjdG9yXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0RWxlbWVudChlbDogSFRNTEVsZW1lbnQgfCBFbGVtZW50UmVmIHwgc3RyaW5nLCBwYXJlbnQ/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcclxuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiAocGFyZW50IHx8IHRoaXMuX2RvY3VtZW50KS5xdWVyeVNlbGVjdG9yKGVsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2VyY2VFbGVtZW50PEhUTUxFbGVtZW50PihlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyBhIGRlc3Ryb3llciBzdHJlYW0sIHJlLWluaXRpYWxpemVzIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9pbml0U21vb3RoU2Nyb2xsKGVsOiBIVE1MRWxlbWVudCk6IFN1YmplY3Q8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuX29uR29pbmdTY3JvbGxzLmhhcyhlbCkpIHtcclxuICAgICAgdGhpcy5fb25Hb2luZ1Njcm9sbHMuZ2V0KGVsKS5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fb25Hb2luZ1Njcm9sbHMuc2V0KGVsLCBuZXcgU3ViamVjdDx2b2lkPigpKS5nZXQoZWwpITtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBzbW9vdGggc2Nyb2xsIGhhcyByZWFjaGVkLCBjbGVhbnMgdXAgdGhlIHNtb290aCBzY3JvbGwgc3RyZWFtIGFuZCByZXNvbHZlcyBpdHMgcHJvbWlzZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2lzRmluaXNoZWQoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+LCByZXNvbHZlOiAoKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoY29udGV4dC5jdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGNvbnRleHQuY3VycmVudFkgIT09IGNvbnRleHQueSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3llZC5uZXh0KCk7XHJcbiAgICByZXNvbHZlKCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXJtaW5hdGVzIGFuIG9uZ29pbmcgc21vb3RoIHNjcm9sbFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludGVycnVwdGVkKGVsOiBIVE1MRWxlbWVudCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+KTogT2JzZXJ2YWJsZTxFdmVudCB8IHZvaWQ+IHtcclxuICAgIHJldHVybiBtZXJnZShcclxuICAgICAgZnJvbUV2ZW50KGVsLCAnd2hlZWwnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXHJcbiAgICAgIGZyb21FdmVudChlbCwgJ3RvdWNobW92ZScsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgZGVzdHJveWVkXHJcbiAgICApLnBpcGUodGFrZSgxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGVzIHRoZSBkZXN0cm95ZXIgZnVuY3Rpb24sIHJ1bnMgaWYgdGhlIHNtb290aCBzY3JvbGwgaGFzIGZpbmlzaGVkIG9yIGludGVycnVwdGVkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZGVzdHJveShlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IHZvaWQge1xyXG4gICAgZGVzdHJveWVkLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5kZWxldGUoZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBmdW5jdGlvbiBjYWxsZWQgcmVjdXJzaXZlbHkgdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N0ZXAoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCk6IE9ic2VydmFibGU8U21vb3RoU2Nyb2xsU3RlcD4ge1xyXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFNtb290aFNjcm9sbFN0ZXA+KSA9PiB7XHJcbiAgICAgIGxldCBlbGFwc2VkID0gKHRoaXMuX25vdygpIC0gY29udGV4dC5zdGFydFRpbWUpIC8gY29udGV4dC5kdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXHJcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xyXG5cclxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHQuZWFzaW5nKGVsYXBzZWQpO1xyXG5cclxuICAgICAgY29udGV4dC5jdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xyXG4gICAgICBjb250ZXh0LmN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XHJcblxyXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGNvbnRleHQuc2Nyb2xsYWJsZSwgY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XHJcbiAgICAgIC8vIFByb2NlZWQgdG8gdGhlIHN0ZXBcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHN1YnNjcmliZXIubmV4dChjb250ZXh0KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChlbCwgb3B0aW9ucy5sZWZ0LCBvcHRpb25zLnRvcCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGEgZGVzdHJveWVyIHN0cmVhbSwgcmVpbml0aWFsaXplIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgIGNvbnN0IGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IHRoaXMuX2luaXRTbW9vdGhTY3JvbGwoZWwpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAgPSB7XHJcbiAgICAgIHNjcm9sbGFibGU6IGVsLFxyXG4gICAgICBzdGFydFRpbWU6IHRoaXMuX25vdygpLFxyXG4gICAgICBzdGFydFg6IGVsLnNjcm9sbExlZnQsXHJcbiAgICAgIHN0YXJ0WTogZWwuc2Nyb2xsVG9wLFxyXG4gICAgICB4OiBvcHRpb25zLmxlZnQgPT0gbnVsbCA/IGVsLnNjcm9sbExlZnQgOiB+fm9wdGlvbnMubGVmdCxcclxuICAgICAgeTogb3B0aW9ucy50b3AgPT0gbnVsbCA/IGVsLnNjcm9sbFRvcCA6IH5+b3B0aW9ucy50b3AsXHJcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxyXG4gICAgICBlYXNpbmc6IEJlemllckVhc2luZyhvcHRpb25zLmVhc2luZy54MSwgb3B0aW9ucy5lYXNpbmcueTEsIG9wdGlvbnMuZWFzaW5nLngyLCBvcHRpb25zLmVhc2luZy55MilcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAvLyBTY3JvbGwgZWFjaCBzdGVwIHJlY3Vyc2l2ZWx5XHJcbiAgICAgIG9mKG51bGwpLnBpcGUoXHJcbiAgICAgICAgZXhwYW5kKCgpID0+IHRoaXMuX3N0ZXAoY29udGV4dCkucGlwZShcclxuICAgICAgICAgIHRha2VXaGlsZSgoY3VyckNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApID0+IHRoaXMuX2lzRmluaXNoZWQoY3VyckNvbnRleHQsIGRlc3Ryb3llZCwgcmVzb2x2ZSkpXHJcbiAgICAgICAgKSksXHJcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX2ludGVycnVwdGVkKGVsLCBkZXN0cm95ZWQpKSxcclxuICAgICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLl9kZXN0cm95KGVsLCBkZXN0cm95ZWQpKVxyXG4gICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNtaXNzIGFuIG9uZ29pbmcgc2Nyb2xsXHJcbiAgICogQHBhcmFtIGVsXHJcbiAgICovXHJcbiAgZGlzbWlzc09uZ29pbmdTY3JvbGwoZWw6IEhUTUxFbGVtZW50KSB7XHJcbiAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5nZXQoZWwpPy5uZXh0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIG9mZnNldHMuIFRoaXMgaXMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2Nyb2xsVG9cclxuICAgKiBtZXRob2QsIHNpbmNlIGJyb3dzZXJzIGFyZSBub3QgY29uc2lzdGVudCBhYm91dCB3aGF0IHNjcm9sbExlZnQgbWVhbnMgaW4gUlRMLiBGb3IgdGhpcyBtZXRob2RcclxuICAgKiBsZWZ0IGFuZCByaWdodCBhbHdheXMgcmVmZXIgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIHNjcm9sbGluZyBjb250YWluZXIgaXJyZXNwZWN0aXZlXHJcbiAgICogb2YgdGhlIGxheW91dCBkaXJlY3Rpb24uIHN0YXJ0IGFuZCBlbmQgcmVmZXIgdG8gbGVmdCBhbmQgcmlnaHQgaW4gYW4gTFRSIGNvbnRleHQgYW5kIHZpY2UtdmVyc2FcclxuICAgKiBpbiBhbiBSVEwgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICogQHBhcmFtIGN1c3RvbU9wdGlvbnMgc3BlY2lmaWVkIHRoZSBvZmZzZXRzIHRvIHNjcm9sbCB0by5cclxuICAgKi9cclxuICBzY3JvbGxUbyhzY3JvbGxhYmxlOiBTbW9vdGhTY3JvbGxFbGVtZW50LCBjdXN0b21PcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybSkpIHtcclxuICAgICAgY29uc3QgZWwgPSB0aGlzLl9nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xyXG4gICAgICBjb25zdCBpc1J0bCA9IGdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XHJcbiAgICAgIGNvbnN0IHJ0bFNjcm9sbEF4aXNUeXBlID0gZ2V0UnRsU2Nyb2xsQXhpc1R5cGUoKTtcclxuXHJcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyA9IHtcclxuICAgICAgICAuLi4odGhpcy5fZGVmYXVsdE9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KSxcclxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxyXG4gICAgICAgIC4uLih7XHJcbiAgICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxyXG4gICAgICAgICAgbGVmdDogY3VzdG9tT3B0aW9ucy5sZWZ0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLmVuZCA6IGN1c3RvbU9wdGlvbnMuc3RhcnQpIDogY3VzdG9tT3B0aW9ucy5sZWZ0LFxyXG4gICAgICAgICAgcmlnaHQ6IGN1c3RvbU9wdGlvbnMucmlnaHQgPT0gbnVsbCA/IChpc1J0bCA/IGN1c3RvbU9wdGlvbnMuc3RhcnQgOiBjdXN0b21PcHRpb25zLmVuZCkgOiBjdXN0b21PcHRpb25zLnJpZ2h0XHJcbiAgICAgICAgfSBhcyBfV2l0aG91dDxfQm90dG9tICYgX1RvcD4pXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBSZXdyaXRlIHRoZSBib3R0b20gb2Zmc2V0IGFzIGEgdG9wIG9mZnNldC5cclxuICAgICAgaWYgKG9wdGlvbnMuYm90dG9tICE9IG51bGwpIHtcclxuICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfQm90dG9tPiAmIF9Ub3ApLnRvcCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCAtIG9wdGlvbnMuYm90dG9tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXdyaXRlIHRoZSByaWdodCBvZmZzZXQgYXMgYSBsZWZ0IG9mZnNldC5cclxuICAgICAgaWYgKGlzUnRsICYmIHJ0bFNjcm9sbEF4aXNUeXBlICE9PSBSdGxTY3JvbGxBeGlzVHlwZS5OT1JNQUwpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcclxuICAgICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9MZWZ0PiAmIF9SaWdodCkucmlnaHQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5JTlZFUlRFRCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0ID8gLW9wdGlvbnMucmlnaHQgOiBvcHRpb25zLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfUmlnaHQ+ICYgX0xlZnQpLmxlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCB0byBlbGVtZW50IGJ5IHJlZmVyZW5jZSBvciBzZWxlY3RvclxyXG4gICAqL1xyXG4gIHNjcm9sbFRvRWxlbWVudChzY3JvbGxhYmxlOiBTbW9vdGhTY3JvbGxFbGVtZW50LCB0YXJnZXQ6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5fZ2V0RWxlbWVudCh0YXJnZXQsIHNjcm9sbGFibGVFbCk7XHJcbiAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXHJcbiAgICAgIC4uLntcclxuICAgICAgICBsZWZ0OiB0YXJnZXRFbC5vZmZzZXRMZWZ0ICsgKGN1c3RvbU9wdGlvbnMubGVmdCB8fCAwKSxcclxuICAgICAgICB0b3A6IHRhcmdldEVsLm9mZnNldFRvcCArIChjdXN0b21PcHRpb25zLnRvcCB8fCAwKVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRhcmdldEVsID8gdGhpcy5zY3JvbGxUbyhzY3JvbGxhYmxlRWwsIG9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==