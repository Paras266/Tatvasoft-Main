/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, Input } from '@angular/core';
import { isChanged } from '@progress/kendo-angular-common';
import { Subscription } from 'rxjs';
import { isPresent } from './util';
import * as i0 from "@angular/core";
import * as i1 from "./listbox.component";
/**
 * A directive which manages the functoinality of the ListBox tools out of the box, and modifies the provided data accordingly.
 */
export class DataBindingDirective {
    constructor(listbox) {
        this.listbox = listbox;
        this.actionClickSub = new Subscription();
        this.selectedBoxSub = new Subscription();
        this.selectedBox = this.listbox;
        this.actionClickSub.add(this.listbox.actionClick.subscribe((actionName) => {
            switch (actionName) {
                case 'moveUp': {
                    this.moveVertically('up');
                    break;
                }
                case 'moveDown': {
                    this.moveVertically('down');
                    break;
                }
                case 'transferTo': {
                    this.transferItem(this.connectedWith, this.listbox);
                    break;
                }
                case 'transferFrom': {
                    this.transferItem(this.listbox, this.connectedWith);
                    break;
                }
                case 'transferAllTo': {
                    this.transferAll(this.listbox, this.connectedWith);
                    break;
                }
                case 'transferAllFrom': {
                    this.transferAll(this.connectedWith, this.listbox);
                    break;
                }
                case 'remove': {
                    this.removeItem();
                    break;
                }
                default: {
                    break;
                }
            }
        }));
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (isChanged('connectedWith', changes, false)) {
            if (!changes.connectedWith.firstChange) {
                this.selectedBoxSub.unsubscribe();
                this.selectedBoxSub = new Subscription();
            }
            this.selectedBoxSub.add(this.listbox.selectionChange.subscribe(() => {
                this.selectedBox = this.listbox;
                this.connectedWith.clearSelection();
            }));
            this.selectedBoxSub.add(this.connectedWith.selectionChange.subscribe(() => {
                this.selectedBox = this.connectedWith;
                this.listbox.clearSelection();
            }));
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.actionClickSub) {
            this.actionClickSub.unsubscribe();
            this.actionClickSub = null;
        }
        if (this.selectedBoxSub) {
            this.selectedBoxSub.unsubscribe();
            this.selectedBoxSub = null;
        }
    }
    moveVertically(dir) {
        const index = this.selectedBox.selectedIndex;
        if (!isPresent(index)) {
            return;
        }
        const topReached = dir === 'up' && index <= 0;
        const bottomReached = dir === 'down' && index >= this.selectedBox.data.length - 1;
        if (topReached || bottomReached) {
            return;
        }
        const newIndex = dir === 'up' ? index - 1 : index + 1;
        // ES6 Destructuring swap
        [this.selectedBox.data[newIndex], this.selectedBox.data[index]] = [this.selectedBox.data[index], this.selectedBox.data[newIndex]];
        this.selectedBox.selectionService.select(newIndex);
    }
    removeItem() {
        const index = this.selectedBox.selectedIndex;
        if (!isPresent(index)) {
            return;
        }
        this.selectedBox.data.splice(index, 1);
        this.selectedBox.selectionService.clearSelection();
    }
    transferItem(source, target) {
        const item = source && source.data[source.selectedIndex];
        if (!item || !target || !source) {
            return;
        }
        target.data.push(item);
        source.data.splice(source.selectedIndex, 1);
        source.clearSelection();
        target.selectItem(target.data.length - 1);
        this.selectedBox = target;
    }
    transferAll(source, target) {
        if (!target || !source) {
            return;
        }
        target.data.splice(target.data.length, 0, ...source.data.splice(0, source.data.length));
        target.selectItem(target.data.length - 1);
        this.selectedBox = target;
    }
}
DataBindingDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DataBindingDirective, deps: [{ token: i1.ListBoxComponent }], target: i0.ɵɵFactoryTarget.Directive });
DataBindingDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: DataBindingDirective, selector: "[kendoListBoxDataBinding]", inputs: { connectedWith: "connectedWith" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DataBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoListBoxDataBinding]'
                }]
        }], ctorParameters: function () { return [{ type: i1.ListBoxComponent }]; }, propDecorators: { connectedWith: [{
                type: Input
            }] } });
